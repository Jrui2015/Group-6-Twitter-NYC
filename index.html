<html>
  <head>
    <title>Twitter NYC</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/leaflet.css" />
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <style>
     svg {
       position: relative;
     }

     path {
       fill: #ffd800;
       fill-opacity: .8;
     }

     path:hover {
       fill: brown;
       fill-opacity: .7;
     }

     #map {
       position: absolute;
       height: 100%;
       width: 100%;
       background-color: #333;
     }
    </style>
  </head>

  <body>
    <div id="map" style="min-height: 600px"></div>
  </body>

  <script src="http://cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>
  <script src="/socket.io/socket.io.js"></script>
  <script src="//d3js.org/d3.v3.js"></script>
  <script>
   var NYC = [40.7317, -73.9841];
   var map = L.map('map').setView(NYC, 12);
   L.tileLayer("http://{s}.sm.mapstack.stamen.com/(toner-lite,$fff[difference],$fff[@23],$fff[hsl-saturation@20])/{z}/{x}/{y}.png").addTo(map);
   var svg = d3.select( map.getPanes().overlayPane )
               .append('svg');

   var g = svg.append('g')
              .attr('class', 'leaflet-zoom-hide tweets')

   function projectPoint(x, y) {
     var point = map.latLngToLayerPoint(new L.LatLng(y, x));
     this.stream.point(point.x, point.y);
   }

   var transform = d3.geo.transform({ point: projectPoint });
   var path = d3.geo.path().projection(transform);
   map.on('moveend', mapMove);


   var geoData = {
     type: 'FeatureCollection',
     features: []
   };
   // Have to specify the extent when contructing incrementally
   // otherwise you will see stack overflow
   var qtree = d3.geom.quadtree([], -180, -90, 180, 90);
   var socket = io();
   socket.on('tweet', function(tweet) {
     if (tweet.coordinates) {
       geoData.features.push({
         id_str: tweet.id_str,
         type: 'Feature',
         geometry: tweet.coordinates
       });
       qtree.add({
         x: tweet.coordinates.coordinates[0],
         y: tweet.coordinates.coordinates[1],
         all: {
           id_str: tweet.id_str,
           type: 'Feature',
           geometry: tweet.coordinates
         }
       });
       computeNodeRect(qtree);
       mapMove();
     }
   });


   function computeNodeRect(quadtree) {
     var nodes = [];
     quadtree.depth = 0;

     quadtree.visit(function(node, x1, y1, x2, y2) {
       var nodeRect = {
         left: MercatorXofLongitude(x1),
         right: MercatorXofLongitude(x2),
         bottom: MercatorYofLatitude(y1),
         top: MercatorYofLatitude(y2)
       }
       node.width  = nodeRect.right - nodeRect.left;
       node.height = nodeRect.top   - nodeRect.bottom;

       nodes.push(node);
       for (var i = 0; i < 4; i++) {
         if (node.nodes[i]) node.nodes[i].depth = node.depth + 1;
       }
     });
     return nodes;
   }

   function mapMove() {
     var bounds = map.getBounds();
     var subset = search(qtree,
                         bounds.getWest(), bounds.getSouth(),
                         bounds.getEast(), bounds.getNorth());

     redrawSubset(subset);
   }

   function search(quadtree, x0, y0, x3, y3) {
     var pts = [];
     quadtree.visit(function(node, x1, y1, x2, y2) {
       var pt = node.point;
       if (pt && pt.x >= x0 && pt.x < x3 && pt.y >= y0 && pt.y < y3) {
         pts.push(pt.all);
       }
       return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
     });
     return pts;
   }

   function redrawSubset(subset) {
     if (subset.length == 0) { return false; }
     path.pointRadius(3); // * scale

     var bounds = path.bounds({
       type: 'FeatureCollection',
       features: subset
     });

     var padding = 30;
     var topLeft = bounds[0].map(x => x - padding);
     var bottomRight = bounds[1].map(x => x + padding);

     svg.attr({
       width: bottomRight[0] - topLeft[0],
       height: bottomRight[1] - topLeft[1],
     }).style({
       left: `${topLeft[0]}px`,
       top: `${topLeft[1]}px`
     });

     g.attr('transform', `translate(${-topLeft[0]}, ${-topLeft[1]})`);

     var points = g.selectAll('path')
                   .data(subset, d => d.id_str);

     points.enter()
           .append('path')

     points.attr('d', path);

     points.exit().remove();
   }

   function getZoomScale() {
     var mapWidth = map.getSize().x;
     var bounds = map.getBounds();
     var planarWidth = MercatorXofLongitude(bounds.getEast()) -
                       MercatorXofLongitude(bounds.getWest());
     return mapWidth / planarWidth;
   }

   var MercatorXofLongitude = lon => lon * 20037508.34 / 180;
   var MercatorYofLatitude = lat =>
     (Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180)) * 20037508.34 / 180;

  </script>
</html>
